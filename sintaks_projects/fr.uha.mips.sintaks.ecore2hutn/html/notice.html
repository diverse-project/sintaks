<html><head>


<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="Generator" content="Microsoft Word 11 (filtered)"><title>Notice ecore to hutn as sts file</title>

<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	font-size:12.0pt;
	font-family:Tahoma;}
h1
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-align:center;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:Tahoma;}
h2
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-align:justify;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:Tahoma;
	font-weight:normal;}
h3
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-align:justify;
	page-break-after:avoid;
	font-size:13.0pt;
	font-family:Arial;}
p.MsoList, li.MsoList, div.MsoList
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:90.0pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:-63.0pt;
	font-size:12.0pt;
	font-family:Tahoma;}
p.MsoListBullet, li.MsoListBullet, div.MsoListBullet
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:18.0pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:-18.0pt;
	font-size:12.0pt;
	font-family:Tahoma;}
p.Rule, li.Rule, div.Rule
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	font-size:10.0pt;
	font-family:Verdana;}
p.Figure, li.Figure, div.Figure
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:12.0pt;
	font-family:Tahoma;}
p.Image, li.Image, div.Image
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:12.0pt;
	font-family:Tahoma;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:70.85pt 70.85pt 70.85pt 70.85pt;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style></head><body lang="FR">

<div class="Section1">

<h1><span lang="EN-GB">ecore to hutn in sintaks</span></h1>

<h2><span lang="EN-GB">How to</span></h2>

<p class="MsoNormal"><span lang="EN-GB">Requirements: you have to install the
plugin fr.uha.mips.sintaks.ecore2hutn into a sintaks operational eclipse
installation. The activation can be seen as a new menu entry in the sintaks
menu (left figure below).</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Figure"><span lang="EN-GB"><img src="notice_fichiers/image001.jpg" height="303" width="252">&nbsp;&nbsp; <img src="notice_fichiers/image002.png" height="386" width="264"></span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">As you select the new entry "ecore to
sintaks in HUTN", the window on the right figure above is proposed. There
are two parameters to control the transformation. The parameter "adjectives
is allowed" controls the way to reflect the single value attributes: either
as a value before the body or as a key/value pair in the body of an eClass. The
"start" parameter selects the start class in the sintaks root rule.</span></p>

<h2><span lang="EN-GB">Transformation process</span></h2>

<p class="MsoNormal"><span lang="EN-GB">According to the ecore metamodel, several
concepts can be found in an ecore file. Many of them (enumeration, datatype, …)
are relevant to the value carried by other concepts. Packages are not processed
as each class carried itself the owning package. As sintaks relies on the
factory generated by EMF, we don’t care about them. So nowadays, we have only
to process eClasses.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">In fact, two kinds of classes can be found in
an ecore description:</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoListBullet"><span style="font-family: Symbol;" lang="EN-GB">·<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span dir="ltr"><span lang="EN-GB">abstract classes</span></span></p>

<p class="MsoListBullet"><span style="font-family: Symbol;" lang="EN-GB">·<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span dir="ltr"><span lang="EN-GB">concrete classes</span></span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">We assume that an abstract class is an
intermediate class in a hierarchy of classes, a concrete class is always a
standalone class or a LEAF in a hierarchy.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><b><span lang="EN-GB">Warning</span></b><span lang="EN-GB">: this
version is <b>not</b> yet <b>able</b> to well process intermediate concrete
classes.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">Ecore proposes many kinds of slots: in our
concrete syntax we take into account only 'real' plain value slots. All
derived, transient, not settable slots are automatically removed from the set
of available slots. References with an opposite containment are also removed
from the set of available slots.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><b><span lang="EN-GB">Warning</span></b><span lang="EN-GB">: two
opposite references are treated by two different rules (one for each end). This
leads to too many descriptions for the same relationship. You have to remove
one manually.</span></p>

<h2><span lang="EN-GB">Model conventions used in this document</span></h2>

<p class="MsoNormal"><span lang="EN-GB">We call <b>attribute</b> an ecore
attribute. Later we can have single value attribute and multi value attributes.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">We call <b>adjective</b> a single value
attribute.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">We call <b>reference</b> an ecore reference
without containment relationship from both ways (normal and opposite).</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">We call <b>containment</b> an ecore
reference with a normal containment relationship.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">A <b>fragment</b> is a rule owned by the
root concept of a sintaks model.</span></p>

<h2><span lang="EN-GB">Grammar conventions used in this document</span></h2>

<p class="MsoList"><span lang="EN-GB">"xxx"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a constant (keyword).</span></p>

<p class="MsoList"><span lang="EN-GB">&lt;xxx&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a constant (keyword) extracted
from the current concept.</span></p>

<p class="MsoList"><span lang="EN-GB">text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; something associated to a
slot of the model under construction</span></p>

<p class="MsoList"><span lang="EN-GB">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 or more</span></p>

<p class="MsoList"><span lang="EN-GB">+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 or more</span></p>

<p class="MsoList"><span lang="EN-GB">?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 or 1</span></p>

<p class="MsoList"><span lang="EN-GB">(xxx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grammar rule grouping</span></p>

<h2><span lang="EN-GB">Transformation about a concrete class</span></h2>

<p class="MsoNormal"><span lang="EN-GB">The transformation consists in creating a
sintaks template handling the class. Let say that the current class is
represented by the name eClass, we can propose the EBNF rules below to describe
the produced template.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">Template&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::=&nbsp;&nbsp;&nbsp;&nbsp; &lt;eClass.name&gt;
id ? adjectives ? body "eoln"</span></p>

<p class="Rule"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::=&nbsp;&nbsp;&nbsp;&nbsp; value ?</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">The id rule means that we try to find an id
attribute in the ecore model. If we find one we use it as an "id" for
the template else we do not generate the rule.</span></p>

<p class="Rule"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">adjectives&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::=&nbsp;&nbsp;&nbsp;&nbsp; "("
eClass.adjective * ")"</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">The optional adjectives rules states that
if the directive isAdjectiveAllowed is not set or the current eClass doesn’t
contain adjectives nothing is generated else a list of adjectives enclosed with
parenthesis is generated. The order of the list belongs to the order of the ecore
attributes.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::=&nbsp;&nbsp;&nbsp;&nbsp; "{"
"eoln" ( content "eoln" ) + "}"</span></p>

<p class="Rule"><span lang="EN-GB">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ";"</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">The body rule states that if additional
content have to be described, we produce it one per line (to enhance
readability), enclosed with curly braces else we just close the class
description using a semi colon.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">content&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::=&nbsp;&nbsp;&nbsp;&nbsp; attribute
| reference | container | shared</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">The content rule is about complex content
such as multiple value slots or isAdjectiveAllowed is not set all single value
attribute. Unfortunately the order is not so free as stated above but uses a
complex ordering not relevant in this document as you can freely change it in
the generated file.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">shared&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::=&nbsp;&nbsp;&nbsp;&nbsp; RULEREF(id)</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">A shared slot means that we process a slot
belonging to a mother (abstract) class and not to the current class. All
children should share the same concrete representation. We propose to use a
special concept in sintaks which allows calling a fragment known by its unique id
(concatenation of the eClass owning the slot, a dot and the slot name). It is
now the responsibility of the fragment to handle correctly the shared slot.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">attribute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::=&nbsp;&nbsp;&nbsp;&nbsp; singleValueAttribute
| multipleValueAttribute</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">singleValueAttribute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= &lt;eAttribute.name&gt;
'=' value ';'</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">A single value attribute (not used as id or
adjective) are represented by pair name/value separated by an equal sign and
terminated by a semicolon.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">multipleValueAttribute&nbsp;&nbsp;&nbsp;&nbsp; ::=
&lt;eAttribute.name&gt; '=' '[' value ( ',' value ) * ']' ';'</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">A multiple value attribute is represented
by a name and values separated by an equal sign and terminated by a semicolon. All
the values are in a comma separated list of single value enclosed by brackets.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">reference&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::=&nbsp;&nbsp;&nbsp;&nbsp; singleValueReference
| multipleValueReference</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">singleValueReference&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp;&nbsp;&nbsp;&nbsp; &lt;eReference.name&gt;
'=' OR(key) ';'</span></p>

<p class="Rule"><span lang="EN-GB">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: Symbol;" lang="EN-GB">e</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">A single value Reference is processed by a
complex rule. We generate a custom condition to check at runtime if the value is
filled or not. If the reference is empty we do nothing else we generate a
sequence composed by its name, an equal sign, an ObjectReference indexed by the
id attribute of the referenced class and a semicolon to terminate the rule.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">multipleValueReference&nbsp;&nbsp; ::=&nbsp;&nbsp;&nbsp;&nbsp; &lt;eReference.name&gt;
'=' '[' OR(key) ( ',' OR(key)) * ']' ';'</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">We use the same pattern as for the multiple
value attribute except we replace the value by the OR(key) pattern (same
meaning as for the single value reference).</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">container&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
::=&nbsp;&nbsp;&nbsp;&nbsp; singleValueContainer
| multipleValueContainer</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">singleValueContainer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp;&nbsp;&nbsp;&nbsp; &lt;eContainer.name&gt;
':' RULEREF(eClass.name)</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">A case of a single value container, we
start by the name of the container followed by the colon sign and end with a
ruleref to the rule belonging to the class to handle by the container.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Rule"><span lang="EN-GB">multipleValueContainer&nbsp;&nbsp;&nbsp; ::=&nbsp;&nbsp;&nbsp;&nbsp; &lt;eCont.name&gt;
'[' RULEREF(eCont.name) * ']'</span></p>

<p class="Rule"><span lang="EN-GB">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: Symbol;" lang="EN-GB">e</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">A multiple value container is processed by
a complex rule. We generate a custom condition to check at runtime if the value
is filled or not. If the container is empty we do nothing else we generate a
sequence composed by its name and enclosed into brackets, an iteration over the
container. The iteration calls a ruleref to the rule belonging to the class.</span></p>

<h2><span lang="EN-GB">Transformation about an abstract class</span></h2>

<p class="MsoNormal"><span lang="EN-GB">The transformation consists in creating
several fragments.</span></p>

<p class="MsoNormal"><span lang="EN-GB">The most important one is about the
abstract class itself. We create an alternative with a collection of
polymorphic conditions composed over the list of all concrete subclasses.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">For each slot local to the abstract class
we create a fragment composed by rules similar as those describes in the
concrete class. So they can be shared among sub classes.</span></p>

<h2><span lang="EN-GB">Expression examples</span></h2>

<p class="MsoNormal"><span lang="EN-GB">We propose the following metamodel :</span></p>

<p class="Figure"><span lang="EN-US"><img src="notice_fichiers/image003.jpg" height="206" width="371"></span></p>

<p class="MsoNormal"><span lang="EN-US">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-US">If we use our transformation tool, we
obtain the following concrete syntax.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB"><img src="notice_fichiers/image004.jpg" height="193" width="213">&nbsp;<img src="notice_fichiers/image005.jpg" height="206" width="182">&nbsp;<img src="notice_fichiers/image006.jpg" height="291" width="194"></span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">The figure on the left describes four
fragments.</span></p>

<p class="MsoNormal"><span lang="EN-GB">The first fragment is about the Expr abstract
class and contains the three polymorphic conditions over the three concrete
classes. The BinaryOperator_lhs and BinaryOperator_rhs describe the shared
containment lhs and rhs in the abstract BinaryOperator class. They are composed
by a "lhs" (rhs) terminal, a colon separator and a ruleref to the
expr fragment (the preceding alternative). The last fragment can be safely
removed as it is a fragment about an intermediate abstract class and the
process proposed does not rely on such intermediate classes.</span></p>

<p class="MsoNormal"><span lang="EN-GB">The figure on the middle describes 3
fragments about concrete classes. The multiplicativeOp template starts by the
adequate terminal, opens a curly brace, rulerefs the lhs fragment, the rhs fragment
and ends by a curly brace. The NumberInteger template first extracts a terminal
followed by its value, the semicolon and ends. The third template (additiveOp)
uses the same construction as the multiplicativeOperator.</span></p>

<p class="MsoNormal"><span lang="EN-GB">The figure on the right describes the Model
template, the root of an expression model. It starts by the terminal Model and
enclosed by curly braces first something about the children containment
followed by the child containment. If the children containment is empty nothing
is produced else we start by the terminal children followed by the list of
children (one per line) enclosed by brackets. One child in the list is
described using the Expr fragment. The child containment is just a terminal
followed by a colon and a ruleref to the Expr fragment.</span></p>

<h2><span lang="EN-GB">TinyJava exemple</span></h2>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="Image"><span lang="EN-GB"><img src="notice_fichiers/image007.jpg" height="173" width="355"></span></p>

<p class="MsoNormal"><span lang="EN-GB">In the tinyJava example, we propose the above
meta model and we obtain a sintaks model, some excerpts are presented on the
figure below.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB"><img src="notice_fichiers/image008.jpg" height="304" width="219">&nbsp;&nbsp; <img src="notice_fichiers/image009.jpg" height="361" width="197"></span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">The TJClass template is really interesting.
It starts first by the terminal "TJClass" (later you can change it to
class), its name, enclosed by parenthesis the three attributes (later you can
reorder them), and ends by the body. The body is just about the features
container. We proposes an alternative to skip the description if the container
is empty else we have the now common pattern : a terminal and enclosed by
brackets an iteration over the container which rulerefs the TJFeature fragment.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

<p class="MsoNormal"><span lang="EN-GB">The TJFeature is really simple, an
alternative over the two concrete classe. Perhaps, the Data and Method
templates are quite similar (at the beginning) to better share them we can
introduce new constructions, but they are too hard to infer automatically. Of
course, java style suggests to put the attributes at the beginning of the rule
without the parenthesis, you are left to change the template to have a better
way to represent the concepts.</span></p>

<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>

</div>

</body></html>